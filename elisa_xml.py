###ELISA_xml.py
###Functions to parse .xml files generated by ScanIt RE software
###(used to control microplate reader)

import re
import xml.etree.ElementTree as ET
import os



"""
A function to build an output text files containing the parsed
results of ELISA measurement files.
Args:
    -file_loc: a string path to a directory XML files containing the results. 
        formatting of the results files should be correct (see sub-function requirements)
        Note that while the plates don't need to have the exact same layout, the groups 
        specified in the output file need to match, otherwise this function will mix up
        samples from different experiments. 
    -incubation: if True, assumes that samples underwent additional incubation with LPS, and looks for 
        incubation information in the sample names
Returns:
    -None: files saved in specified location file_loc as .txt
"""
def build_results(file_loc,incubation=False):
    ##get the list of xml files in the given directory
    file_list = []
    for f in os.listdir(file_loc):
        if f.endswith(".xml"):
            file_list.append(os.path.join(file_loc, f))
    if len(file_list) <= 0:
        raise ValueError("No files in given directory")
    ##now get the XML root of each file, and label each with which cytokine was measured
    root_dict = {}
    for f in file_list:
        root = ET.parse(f).getroot()
        root_dict[file_id(f)] = root
    root_ids = list(root_dict)
    #find the list of groups present in each file, and make sure they all match. 
    groups = get_groups(root_dict[root_ids[0]])
    for id in root_ids:
        assert set(groups) == set(get_groups(root_dict[id])), "Groups don't match between files"
    ##now we can start to put together our output, which at the top level
    ##is arranged by "group" which really represents all the samples from one experiment.
    for group in groups:
        output = {}
        for cytokine in root_ids:
            output[cytokine] = {}
            c_dict = output[cytokine] ##the cytokine level dictionary for
            c_root = root_dict[cytokine] ##the XML root for this cytokine
            ##add the standards data
            std_conc = get_std_conc(c_root)
            std_abs = get_std_abs(c_root,std_conc)
            c_dict['std'] = std_abs
            ##add the test sample data
            test_ids = get_test_ids(c_root,incubation)
            test_abs = get_test_abs(c_root,test_ids)
            c_dict['test'] = test_abs[group] ##only need the data from the current group!
            ##finally add the control data
            ctrl_ids = get_ctrl_ids(c_root)
            ctrl_abs = get_ctrl_abs(c_root,ctrl_ids)
            c_dict['ctrl'] = ctrl_abs
            ##finally add this dictionary to the output file
            output[cytokine] = c_dict
        ##write this data to an output file
        with open(os.path.join(file_loc,group+' results.py'), 'w') as f:
            print(output, file=f)

"""
Looks for the name of a cytokine in the filename 
as an indicator of what cytokine is being measured in this file. 
Args:
    -fname: string path to the file
Returns:
    -string of cytokine present in the filename; None if it none present. 
"""
##TODO: add support for more cytokines when needed
def file_id(fname):
    id = None
    if re.search('tnf',fname,re.IGNORECASE):
        id = 'tnf'
    elif re.search('il6',fname,re.IGNORECASE):
        id = 'il6'
    elif re.search('il1b',fname,re.IGNORECASE):
        id = 'il1b'
    elif re.search('ne',fname,re.IGNORECASE):
        id='ne'
    else:
        raise ValueError("File name does not contain a valid cytokine ID")
    return id

"""
A function to return the list of groups specified in the file.
Args:
    -root: ElementTree object
Returns:
    -groups: list of groups present in the file
"""
def get_groups(root):
    ##I think the best way to do this is pull the group names from the ResultsSummary.
    summary = root.find('.//ResultsSummary')
    #elements in the summary are grouped by group id, so the "group" label
    ##for each sample in that summary element should all be the same.
    ##so we can just take the first one.
    groups = []
    for summary_element in summary:
        groups.append(summary_element.find('.//Sample').attrib['group'])
    return groups

"""
Function to pull standard concentration values out of the file.
Args:
    -root: Root of the ElementTree object
Returns:
    -std_conc: a dictionary of standard name: standard concentration pairs.
"""
def get_std_conc(root):
    ##Find the sub-tree corresponding to the plate layout, so we can 
    ##get info about what the concentration is of each sample
    plates = root.find('.//Plates') ##the branch containing plate layouts
    ##assume there is only one layout, but warn if more than one is detected
    layouts = [x for x in plates.iter('Plate')]
    plate = layouts[0]
    if len(layouts) > 1:
        print("Detected multiple plate layouts; defaulting to "+plate.attrib['name'])
    ##now find elements that are classified as type = Standard
    standards = [x for x in plate.iter('Sample') if x.find('.//Type').text == 'Standard']
    ##now that we have a list of standard elements, we can build a dictionary with name:concentration pairs
    std_conc = {}
    for e in standards:
        std_conc[e.attrib['name']] = float(e.find('.//value').text)
    return std_conc

"""
A function to return the absorbance values of each standard of a known concentration.
Args:
    -root: XML file root
    -std_conc: dictionary returned by get_std_conc
Returns:
    -std_abs: nested dictionary of standard absorbances for each absorbance tested in the file
"""
def get_std_abs(root,std_conc):
    ##start by finding any result elements in the file.
    all_steps = [x for x in root.iter('ResultStep')]
    ##now find just the elements that have an absorbance measurement
    abs_steps = [y for y in all_steps if 'Absorbance' in y.attrib['name']]
    ##for each absorbance measured, find the absorbance value of each standard of a known concentration
    std_abs = {}
    for measurement in abs_steps:
        for std in list(std_conc):
            ##browse through all samples to find the data corresponding to this standard (usually more than one well)
            ##this is a little convoluted because the result and the sample ID are both children of the step on the same level
            for well in measurement.iter('Coordinate'):
                if well.find('.//Sample').attrib['name'] == std:
                    data = well.find('.//Result')
                    ##add relevant values to the dictionary; create containers if they don't already exist
                    try:
                        loc1 = std_abs[data.attrib['wavelength_ex']+'nm']
                    except KeyError:
                        std_abs[data.attrib['wavelength_ex']+'nm'] = {}
                        loc1 = std_abs[data.attrib['wavelength_ex']+'nm']
                    try:
                       loc2 = loc1[std_conc[std]]
                    except KeyError:
                        loc1[std_conc[std]] = []
                        loc2 = loc1[std_conc[std]]
                    loc2.append(float(data.attrib['value']))
                    ##possible to put flags here in the future to warn if samples are oversaturated
    return std_abs


"""
Helper function to pull the sample time in mins out of the namestring.
***Assumes that the wells are labeled with the timepoint included somewhere with t=xxx format***
Args:
    -namestring: string containing the name of the sample
"""
def parse_sample_time(namestring):
    ##start by finding where the 't=' is in the string
    t_start = namestring.find('t=')
    if t_start<0: ##couldn't find 't='
        t_start = namestring.find('t =') ##try with a space
        if t_start >0: 
            t_start = t_start+3
        else:
            raise ValueError("No valid timepoints in sample name")
    else:
        t_start = t_start+2
    ##ok, now we have the index of the element after the '=' sign. If there are spaces, skip them
    while namestring[t_start] == ' ':
        t_start+=1
    ##now, assuming we are at the start of the time value, so we can build the time string.
    timestring = ''
    while t_start<len(namestring) and namestring[t_start].isdigit():
        timestring+=namestring[t_start]
        t_start+=1
    return int(timestring) ##here assuming that samples are taken at even minutes
    

"""
An alternate function for parsing sample time, in the case where we are taking
samples from one point, and incubating individual fractions of that sample for different 
amounts of time with LPS. Assumes that the incubation period is codified somewhere in the sample name
using "hr" to indicate the incubation length. For example, "t=0, 2hr"
Args:
    -namestring: string containing the sample name
"""
def parse_sample_time2(namestring):
    ##start by finding where the 't=' is in the string
    t_start = namestring.find('t=')
    if t_start<0: ##couldn't find 't='
        t_start = namestring.find('t =') ##try with a space
        if t_start >0: 
            t_start = t_start+3
        else:
            raise ValueError("No valid timepoints in sample name: "+namestring)
    else:
        t_start = t_start+2
    ##ok, now we have the index of the element after the '=' sign. If there are spaces, skip them
    while namestring[t_start] == ' ':
        t_start+=1
    ##now, assuming we are at the start of the time value, so we can build the time string.
    timestring = ''
    while t_start<len(namestring) and namestring[t_start].isdigit():
        timestring+=namestring[t_start]
        t_start+=1
    ##now look for the incubation time
    inc_start = namestring.find('hr')
    if inc_start<0:
        raise ValueError("Couldn't locate incubation time in sample name: "+namestring)
    else:
        ##assume that the incuation time is in front of the hr units
        inc_start -= 1
        ##account for possible spaces
        while namestring[inc_start] == ' ':
            inc_start -= 1
        incstring = ''
        while inc_start>0 and namestring[inc_start].isdigit():
            incstring+=namestring[inc_start]
            inc_start-=1
    return timestring+"_"+incstring+"hr"


"""
A function to get the identities of the unknown wells, including what group 
they belong to, the dilution factor, as well as what timepoint they represent.
Args:
    -root: root of ElementTree object
Returns:
    -grouped_samples: dictionary of sample groups with name:timepoint pairs
"""
def get_test_ids(root,incubation=False):
    ##Find the sub-tree corresponding to the plate layout
    plates = root.find('.//Plates') ##the branch containing plate layouts
    ##assume there is only one layout, but warn if more than one is detected
    layouts = [x for x in plates.iter('Plate')]
    plate = layouts[0]
    if len(layouts) > 1:
        print("Detected multiple plate layouts; defaulting to "+plate.attrib['name'])
    ##now we find the samples that are classified as "unknowns"
    unknowns = [x for x in plate.iter('Sample') if x.find('.//Type').text == 'Unknown']
    ##create a set of nested dictionaries for each group in the layout, that includes
    ##the sample names that belong to that group, and under that, what timepoint they represent
    ##along with what dilution factor was used
    groups = {}
    for sample in unknowns:
        group_id = sample.find('.//Groups/SampleGroup').attrib['name']
        dilution = sample.find('.//Dilution/value').text
        ##assume dilution is reported as 1:xx; we only want the divisor
        d_start = dilution.find(':')+1
        dilution = int(dilution[d_start:])
        name = sample.attrib['name']
        ##parse the sample time from the name- use appropriate function based on flags
        if incubation:
            t_sample = parse_sample_time2(name)
        else:
            t_sample = parse_sample_time(name)
        ##now add data to the dictionary, create containers when needed
        ##if there are duplicates, this will be overwritten for each duplicate (but that is OK)
        try:
            group = groups[group_id]
        except KeyError:
            groups[group_id] = {}
            group = groups[group_id]
        group[name] = {}
        group[name]['t_sample'] = t_sample
        group[name]['dilution'] = dilution
    return groups


"""
A function to return the absorbance values of each unknown sample (ie test samples).
Args:
    -root: ElementTree root object
    -groups: nested dictionary of the type produced by the get_test_ids function
Returns:
    -test_abs: nested dictionaries with the absorbance values of the different unknown samples
"""
def get_test_abs(root,groups):
    ##start by finding any result elements in the file.
    all_steps = [x for x in root.iter('ResultStep')]
    ##now find just the elements that have an absorbance measurement
    abs_steps = [y for y in all_steps if 'Absorbance' in y.attrib['name']]
    ##now, we want to build an output dictionary that's similar to what we use in the elisa_results file. 
    ##the top level will be grouped according to the 'groups' we found in the earlier step.
    test_abs = {}
    ##preload some known dictionary entries
    for id in groups:
        test_abs[id] = {}
        test_abs[id]['dilution'] = []
    ##now, run through each absorbance, and rearrange the values into the correct place in the output. 
    for measurement in abs_steps:
        for group_id in list(groups):
            group = groups[group_id]
            for sample_name in list(groups[group_id]):
                ##now, find the results for this particular measurement for each of the duplicates of this sample present
                for well in measurement.iter('Coordinate'):
                    if well.find('.//Sample').attrib['name'] == sample_name:
                        data = well.find('.//Result')
                        ##add relevant values to the dictionary; create containers if they don't already exist
                        try:
                            loc1 = test_abs[group_id][data.attrib['wavelength_ex']+'nm']
                        except KeyError:
                            test_abs[group_id][data.attrib['wavelength_ex']+'nm'] = {}
                            loc1 = test_abs[group_id][data.attrib['wavelength_ex']+'nm']
                        try:
                            loc2 = loc1[group[sample_name]['t_sample']]
                        except KeyError:
                            loc1[group[sample_name]['t_sample']] = []
                            loc2 = loc1[group[sample_name]['t_sample']]
                        loc2.append(float(data.attrib['value']))
                        ##possible to put flags here in the future to warn if samples are oversaturated
    ##we only want to add the dilutions once, this has to be a separate loop
    for group_id in list(groups):
        group = groups[group_id]
        for sample_name in list(groups[group_id]):
            test_abs[group_id]['dilution'].append(group[sample_name]['dilution'])
    return test_abs


"""
A function to get the identities (names) of the control wells, if any.  
Args:
    -root: root of ElementTree object
Returns:
    -ctrl_ids: list of sample names classified as control
"""
def get_ctrl_ids(root):
    ##Find the sub-tree corresponding to the plate layout, so we can 
    ##get info about what the concentration is of each sample
    plates = root.find('.//Plates') ##the branch containing plate layouts
    ##assume there is only one layout, but warn if more than one is detected
    layouts = [x for x in plates.iter('Plate')]
    plate = layouts[0]
    if len(layouts) > 1:
        print("Detected multiple plate layouts; defaulting to "+plate.attrib['name'])
    ##now find elements that are classified as type = Control
    ctrls = [x for x in plate.iter('Sample') if x.find('.//Type').text == 'Control']
    ##now that we have a list of control elements, we can build a list of names
    ctrl_ids = [e.attrib['name'] for e in ctrls]
    return ctrl_ids

"""
A function to return control absorbance values, if they exist. If not
it returns an empty placeholder so our analysis functions don't get mad.
Args:
    -root: root of ElementTree object
    -ctrl_ids: list of well ids that contain control samples
Returns:
    -ctrl_abs: dictionary of absorbance values for control samples
"""
def get_ctrl_abs(root,ctrl_ids):

    ##start by finding any result elements in the file.
    all_steps = [x for x in root.iter('ResultStep')]
    ##now find just the elements that have an absorbance measurement
    abs_steps = [y for y in all_steps if 'Absorbance' in y.attrib['name']]
    ##first check to see if we even have controls in this plate. If not, 
    ##just return a placeholder. 
    if len(ctrl_ids)>0:
    ##for each absorbance measured, find the absorbance value of each control
        ctrl_abs = {}
        for measurement in abs_steps:
            for ctrl in ctrl_ids:
                ##browse through all samples to find the data corresponding to this control (usually more than one well)
                ##this is a little convoluted because the result and the sample ID are both children of the step on the same level
                for well in measurement.iter('Coordinate'):
                    if well.find('.//Sample').attrib['name'] == ctrl:
                        data = well.find('.//Result')
                        ##add relevant values to the dictionary; create containers if they don't already exist
                        try:
                            loc1 = ctrl_abs[data.attrib['wavelength_ex']+'nm']
                        except KeyError:
                            ctrl_abs[data.attrib['wavelength_ex']+'nm'] = []
                            loc1 = ctrl_abs[data.attrib['wavelength_ex']+'nm']
                        loc1.append(float(data.attrib['value']))
                        ##possible to put flags here in the future to warn if samples are oversaturated
    else:
        ##if we don't have any control samples, then we have to figure out what wavelengths
        ##were used so we can make the appropriate blanks.
        abs_step_ids = [x.attrib['name'] for x in abs_steps] ##list of names of absorbance steps used
        ##now find the child branch with the information about the protocol
        protocol_info = root.find('.//ProtocolSteps')
        abs_step_info = protocol_info.findall('.//ProtocolStep')
        ##filter only those corresponding to the absorbance steps
        abs_step_info = [x for x in abs_step_info if x.attrib['name'] in abs_step_ids]
        ##now just grab the wavelength info, formatted with the units
        wavelengths = [x.find('.//Wavelength').text+'nm' for x in abs_step_info]
        ##now just create blank values in the return dictionary
        #*****ASSUMING HERE THAT THE CONTROL WAS DONE IN DUPLICATE***
        ctrl_abs = {}
        for wl in wavelengths:
            ctrl_abs[wl] = [0.0,0.0]
    return ctrl_abs
